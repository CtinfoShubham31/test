Laravel
<?php 
Laravel is a free open-source PHP web framework. It is created by Taylor Otwell. Laravel comes with built-in support for user authentication and authorization which is missing in some most popular PHP frameworks like CodeIgniter, CakePHP.
- Laravel is developed on the MVC (Model-View-Controller) design pattern.
- Comes with inbuilt features/ modules like authentication, authorization, localization, models, views, sessions, paginations and routing
- Supports advanced concepts of PHP and OOPs like Dependency Injection, traits, Contracts, bundles, Namespaces, Facades
- Supports Multiple Databases like MySQL, PostgreSQL, SQLite, SQL Server.
- Allow developers to write clean and modular code.
- Supports blade Template Engine
- Comes with Official Packages like Cashier, Envoy, Horizon, Passport, Scout, Socialite
- Used with various popular Javascript Frameworks Like AngularJs, VueJs, ReactJS.

Laravel creator Taylor Otwel.
> It provide features such as built-in support for user authentication and authorization	
> php artisan
> Eloquent ORM(Object Relation Mapping)
 - one to one relationship
> CSRF Token
> MVC
> Migration
?>

Laravel Life Cycle
<?php 
# Auto Loader
Firstly public/index.php is the main entry point of laravel. It loads the auto loaders file which generated by composer. Then it retrieves an instance of the Laravel application from "bootstrap/app.php" script. Laravel itself creates an instance of the application, is the initial/first step.

# Kernel
The incoming request is sent to either the HTTP kernel or the console kernel, depending on the type of request that is entering the application .These two kernels serve as the central location that all requests flow through.
		HTTP kernel, which is placed in app/Http/Kernel.php. It just receive a Request and return a Response. 
HTTP Kernel will define the list of middleware that are passed through before handled by application.

# Service Providers
Next step of the kernel is to load service providers as part of the bootstrapping action. Providers that are needed for the application are placed in config/app.php configuration file.

While the register method calls, all the providers will be registered. Once all providers are registered, then boot method will be called.

# Dispatch Request
Once the application have been bootstrapped and all service providers are registered and booted, the request will be handed over to the router for dispatching. The router will dispatch the request to a route or controller, as well as run any route specific middleware.

# Router:
Now request will be dispatched by the Router and it will end up with the views as shown below:

Router will direct the HTTP Request to a Controller or return a view or responses directly by omitting the controller. These routes will be placed in app/routes.php.

Controller app/controllers/ performs specific actions and sends data to a View.

View app/views/ formats the data appropriately, providing the HTTP Response.
?>

Service Container
<?php
The Laravel service container is a powerful tool for managing class dependencies and performing dependency injection.
In the simplest way to understand service container, we can assume that it is a box that holds various components’ bindings, and they are served as needed throughout the application.


bootstrap/app.php
application.php
class Appllication extends Container implements ApplicationContract, HttpKernelInterface{
	
}

class Container{
	
}

container just bindings or an array

The Laravel service container is a powerful tool for managing class dependencies and performing dependency injection.
The Service Container is a dependency injection container and a registry for application. Instead of creating objects manually the benefits of using Service Container are: It has the capacity to manage class dependencies.

Service container is just a class where we can register different classes or dependencies.

	
# Access bind method by three method:
------(web.php)------
=> App::bind()  //Using Class 
=> app()->bind()	//Facades
=> $this->app->bind()
=> $this->app->singleton

https://stackoverflow.com/questions/37038830/what-is-the-concept-of-service-container-in-laravel/48239728
https://alanstorm.com/binding_objects_as_laravel_services/
https://alanstorm.com/laravel_objects_make/
https://laracasts.com/series/laravel-from-scratch-2017/episodes/24
http://codedog.net/2017/12/07/the-laravel-service-container-not-as-scary-as-you-think/

App::bind() bind for service container.
To bind any container, reference to any class path.	
Like, 
App::bind('App\Billing\Stripe', function(){			//Register a class with service container.
	return new App\Billing\Stripe(config('services.stripe.secret'))
})

$stripe = App::make('App\Billing\Stripe');
dd($stripe);

container was made for: binding and resolving classes.
The Service Container in Laravel is a Dependency Injection Container and a Registry for the application.

For example, instead of creating objects manually with the new keyword:
//everytime we need YourClass we should pass the dependency manually
$instance = new YourClass($dependency);

Instead, you can register a binding on the Service Container:
//add a binding for the class YourClass 
App::bind( YourClass::class, function()
{
    //do some preliminary work: create the needed dependencies
    $dependency = new DepClass( config('some.value') );

    //create and return the object with his dependencies
    return new YourClass( $dependency );
});

and create an instance through the service container with:

//no need to create the YourClass dependencies, the SC will do that for us!
$instance = App::make( YourClass::class );
?>

Service Provider
<?php 
You can register a service provider by adding it to the providers array in config/app.php like so:
'providers' => [
    // Other Service Providers
    App\Providers\MyCustomServiceProvider::class,
],

https://decodeweb.in/php/php-frameworks/laravel-framework/laravel-service-providers-explained-in-depth/

Service providers in laravel application is the central place where application is bootstrapped.
Service provider prevents multiple instances of classes
?>

Microservice
<?php 
Microservice architectures allow you to scale your application as the number of developers working on your application increases. 
Microservices are an architectural style for web applications, where the functionality is divided up across small web services. 
Microservices are a software development technique—a variant of the service-oriented architecture (SOA) architectural style that structures an application as a collection of loosely coupled services. ... Microservice-based architectures enable continuous delivery and deployment.
The important point at this stage is that each independent service has a business boundary which can be independently developed, tested, deployed, monitored, and scaled. These can be even developed in different programming languages.
With microservices, each service can be implemented in a different technology or language as per the requirements and the business. Any decision to change the technology/language of a service will only require rewriting of that particular service since all microservices are independent of each other. 
In microservices-based applications, the independent teams work on separate microservices. A team will own an entire microservice. There is clear ownership of work with clear control of everything about the service, including development, deployment, and monitoring.
Even with all the benefits offered by microservices architecture, it is not a silver bullet. It has complexities of its own. Think of multiple instances of hundreds of services in a big project. How will you monitor these? In case of any service failures, how will an error be tracked, traced, and debugged?

# Explain more
Microservices, also known as microservices architecture, are a software development architecture that structures an application as a collection of loosely coupled modules. It can be implemented in different technologies and deployed independent of each other. This means changes in one microservice can be taken into production independently so that changes won’t affect other microservices. The idea is to divide large software systems into smaller parts. With microservices, you can make a change to a single service and deploy it independently of the rest of the system. This helps you get your code deployed faster. And if a problem does occur, it can be isolated quickly to an individual service, making rollback fast and easy. This is probably the reason why companies like Netflix and Amazon use these architectures.

Microservices are an example of Service-Oriented Architecture, or SOA,

?>

Web Services
<?php 
In simple terms, a web service is an application accessed over a network using a combination of protocols like HTTP, XML, SMTP, or Jabber. Web services, on the other hand, are a network accessible interface to application functionality that helps expose the functionality of an application to another application.
?>



Command
<?php 
# Create Controller
=> php artisan make:controller TestController

# Create model
php artisan make:model Student

# Create model with migration
php artisan make:model Phone -m

# Create Migration File
=> php artisan make:migration add-phone-number
-----(database\migrations\2019_03_06_142930_add-phone-number.php)---------
Now run command:
php artisan migrate

# Make middleware
php artisan make:middleware test
--------(app/Http/Middleware/test.php)--------

?>


~ Routes
<?php 
Route::get('/sayhello', 'HelloController@index');

-------(HelloController.php)---------
namespace App\Http\Controllers;

Class HelloController extends Controller{
	public function index(){
		echo "Index method from hello controller.";
	}
}

Hit Url => http://localhost/larav/sayhello
o/p => Index method from hello controller
?>

Migration
<?php 
Migration are like version control for your database, allowing your team to easily modify and share the applications database schema.

php artisan make:migration create_post_table
php artisan make:model post

class CreatePostTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('posts', function (Blueprint $table) {
			$table->increments('id');
            $table->string('title');
			$table->text('body');
			$table->timestamps();
		});
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('posts');
    }
}

Now run,
php artisan migrate

Suppose, we want to change our table name from posts to blogs

php artisan migrate:rollback
?>

Model
<?php 
# To remove created_at and updated_at column from table
public $timestamps = false;
?>

Middleware => After request send and before page load, in the middle Middleware is run.
<?php 
# Make middleware
php artisan make:middleware test
?>

Possible ways to Pass Data to Views
<?php 
1. Using array function: array()
2. Using compact function: compact()
3. Using with : with([])
4. Using withVariablename: withName()

1. Using array function: array()
public function call(){
	$users = ["Shubham","Shivam","Karnish","Gaurav"];
	$name = "Online Web Tutor";
	return view("call",array("users",$users,"name",$name));
}

Here, users = key

---------(call.blade.php)-----------
@foreach($users as $user)
	{{$user}}
@endforeach

Channel name: {{$name}}

2. Using compact function: compact()
public function call(){
	$users = ["Shubham","Shivam","Karnish","Gaurav"];
	$name = "Online Web Tutor";
	return view("call",compact("users","name"));
}

3. Using with : with([])
public function call(){
	$users = ["Shubham","Shivam","Karnish","Gaurav"];
	$name = "Online Web Tutor";
	return view("call")->with(["users"=>$users,"name"=>$name]);
}

4. Using withVariablename: withName()
public function call(){
	$users = ["Shubham","Shivam","Karnish","Gaurav"];
	$name = "Online Web Tutor";
	return view("call")->withUsers($users)->withName($name);
}
?>


~ Facades
<?php
https://www.tutorialspoint.com/laravel/laravel_facades.htm

https://appdividend.com/2017/12/02/laravel-5-5-facades-tutorial/
# DB
By using query builder we have facedes "DB"

# Receiving Input from User:
Need to add facade in config/app.php
'aliases' => ['Input' => Illuminate\Support\Facades\Input::Class]

And In Controller Add at the top:
use Input;
	OR
use Illuminate\Support\Facades\Input; //If don`t want to add on aliases.

# use request class and dependency injection.
use Illuminate\Http\Request

----------(AdminController.php)--------------
namespace App\Http\Controllers;
use Illuminate\Http\Request;
use App\Test;
use App\Customer;
use Input;

Class AdminController extends Controller{
	
	public function dashboard(){
		return view('child');
	}
	
	public function formSubmit( Request $request){ 
		//$field_one = $request->get('field_one');
		//$field_one = $request->all();		
		echo $request->field_one;  //Short Cut
		dd($field_one);
		
	}
	
}



# Using Facades, Need Validator Facades.
?>



$fillable AND $guarded
<?php 
In case of mass assignment.
(1) protected $fillable = ['name','address','phone']
$fillable is used to allow only those value which is it contain in it`s array. No other value will save.

(2) protected $fillable = [];
=> No value will pass into db.

(3) protected $guarded = ['is_admin','id','created_at'];
=> Allow all array to save except to is_admin, id, created_at

(4) protected $guarded = [];
=> If we want to allow all fields. No restriction.

?>

Database: Query Builder in Laravel | use DB
<?php 
If we want to use query Builder then in controller file we need to add:
=> use DB
in our controller file.

Route::get('queryrun', 'TestController@queryrun');

# Insert
-------(TestController.php)---------
namespace App\Http\Controllers;

use Illuminate\Http\Request;
use DB;

class TestController extends Controller
{
    public function queryrun(){
		$data = DB::table("companies")->insert(["name"=>"Facebook","email"=>"facebook@test.com"]);
		
		echo $data;
	}
}

# Insert(Multiple Row) Into Table(companies)
$data = DB::table("companies")->insert([["name"=>"Youtube","email"=>"youtube@test.com"],["name"=>"Google","email"=>"google@test.com"]]);

# To fetch the records	
$data = DB::table("companies")->get();
print_r($data);

# Display the fetch data into view.	
$data = DB::table("companies")->get();
return view("query",compact("data"));
	
# Order By Descending By Id
$data = DB::table("companies")->orderBy("id","desc")->get();

# Where Condition
$data = DB::table("companies")->where(["id"=>5])->get();

# Where Condition With first()
$data = DB::table("companies")->where(["id"=>5])->first();

#  Delete Query:
echo $data = DB::table("companies")->where(["id"=>6])->delete();

# Update Query:
echo $data = DB::table("companies")->where(["id"=>5])->update(["name"=>"updated name","email"=>"updated_email@gmail.com"]);

# Aggregate Function
echo $data = DB::table("companies")->count();

# pluck()
$data = DB::table("companies")->pluck("email");
print_r($data)

# select()
$data = DB::table("companies")->select("name","email");
print_r($data)

# Alias
$data = DB::table("companies")->select("name","email as email_id");
print_r($data)
?>

Complete Concept Of Eloquent ORM & Model
<?php 
An ORM stands for object-relational mapper.
Laravel allows us to work with database objects and relationships using an eloquent and expressive syntax. Each table has a particular Model which are used to interact with that table in laravel application.


Eloquent ORM refer to an advanced implementation of the PHP Active Record Pattern, which makes it very easy to interact with application  database. In Laravel, each database table is mapped into corresponding eloquent model and each of the eloquent model object include various methods for retrieving and updating the database.


It has many types of relationships.
> One To One relationships
> One To Many relationships
> Many To Many relationships
> Has Many Through relationships
> Polymorphic relationships
> Many To Many Polymorphic relationships
?>

Laravel Accessors and Mutators
<?php 
We can change field name at run time, using Laravel Accessors and Mutators.

Laravel accessors and mutators are customs, user-defined methods that allow you to format Eloquent attributes. Accessors are used to format attributes when you retrieve them from the database.

1. Defining an accessor
The syntax of an accessor is where getNameAttribute() Name is capitalized attribute you want to access.

public function getNameAttribute($value)
{
    return ucfirst($value);
}

2. Defining a mutator
Mutators format the attributes before saving them to the database.

The syntax of a mutator function is where setNameAttribute() Name is a camel-cased column you want to access. So, once again, let’s use our Name column, but this time we want to make a change before saving it to the database:

public function setNameAttribute($value)
{
    $this->attributes['name'] = ucfirst($value);
}
?>

How to use session in laravel?
<?php 
1. Retrieving Data from session
session()->get('key');

2. Retrieving All session data
session()->all();

3. Remove data from session
session()->forget('key'); or session()->flush();

4. Storing Data in session
session()->put('key', 'value');
?>

Queue
<?php 
Using queue we can send mail in background.
Sending an email is a time-consuming task, so what we will do is, we will create a job that’s the only task is to send an email to the user in the background.
?>

Authentication
<?php 
Authentication is the process of identifying the user credentials. In web applications, authentication is managed by sessions which take the input parameters such as email or username and password, for user identification. If these parameters match, the user is said to be authenticated.
?>

Authorization
<?php 
In authorization, the system or the web application checks if the authenticated users can access the resources that they are trying to access or make a request for. In other words, it checks their rights and permissions over the requested resources. If it finds that they can access the resources, it means that they are authorized.
?>

Localization
<?php 
Localization feature of Laravel supports different language to be used in application. You need to store all the strings of different language in a file and these files are stored at resources/lang. You should create a separate directory for each supported language. All the language files should return an array of keyed strings as shown below.
return [
   'welcome' => 'Welcome to the application'
];

Example:
1. Save English file at resources/lang/en/lang.php
return [
  'msg' => 'Laravel Internationalization example.'
];
?>

Spatie Laravel Permission Package
<?php 
=> composer require spatie/laravel-permission 
?>






